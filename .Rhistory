z.disagg=array(NA,dim=c(n.tsegm,n.grid,n.ac))
y=matrix(0,n.tsegm,n.grid)
for (i in 1:n.tsegm){
z[i,]=rmultinom(1,size=n[i],prob=theta[i,])
for (j in 1:n.ac){
z.disagg[i,,j]=rmultinom(1,size=z[i,j],prob=probs[j,])
y[i,]=y[i,]+z.disagg[i,,j]
}
}
z.true.disagg=z.disagg
image(y)
plot(res$phi,type='l')
abline(h=phi.true,col='red')
plot(res$phi,type='l')
abline(h=phi.true,col='red')
ntot=n.tsegm*n.ac*n.grid
z.estim=apply(res$z,c(1,3),sum)
z.true=apply(z.true.disagg,c(1,3),sum)
ordem=numeric()
for (i in 1:ncol(z.true)){
tmp=rep(NA,ncol(z.estim))
for (j in 1:ncol(z.estim)){
tmp[j]=cor(cbind(z.estim[,j],z.true[,i]))[1,2]
}
ind=which(tmp==max(tmp))
ordem=c(ordem,ind)
}
plot(z.estim[,ordem],z.true)
n.ac=5
ac.coord=matrix(res$coord[ngibbs-1,],n.ac,2)
ac.coord[ordem,]
ac.coord.true
rango=range(c(ac.coord.true),ac.coord[ordem,])
plot(ac.coord.true$x,ac.coord[ordem,1],xlim=rango,ylim=rango)
lines(rango,rango,col='red')
plot(ac.coord.true$y,ac.coord[ordem,2],xlim=rango,ylim=rango)
lines(rango,rango,col='red')
#look at spatial distribution
plot(possib.ac$x,possib.ac$y)
points(ac.coord[,1],ac.coord[,2],col='red')
points(ac.coord.true$x,ac.coord.true$y,col='blue',cex=0.8)
ntot=n.tsegm*n.ac*n.grid
z.estim=apply(res$z,c(1,3),sum)
z.true=apply(z.true.disagg,c(1,3),sum)
ordem=numeric()
for (i in 1:ncol(z.true)){
tmp=rep(NA,ncol(z.estim))
for (j in 1:ncol(z.estim)){
tmp[j]=cor(cbind(z.estim[,j],z.true[,i]))[1,2]
}
ind=which(tmp==max(tmp))
ordem=c(ordem,ind)
}
plot(z.estim[,ordem],z.true)
ordem=numeric()
for (i in 1:ncol(z.true)){
tmp=rep(NA,ncol(z.estim))
for (j in 1:ncol(z.estim)){
tmp[j]=cor(cbind(z.estim[,j],z.true[,i]))[1,2]
}
ind=which(tmp==max(tmp))
print(max(tmp))
ordem=c(ordem,ind)
}
plot(z.estim[,ordem],z.true)
rm(list=ls(all=TRUE))
set.seed(10)
#read important functions
setwd('U:\\GIT_models\\AC_mixed')
library('Rcpp')
sourceCpp('aux1.cpp')
source('gibbs sampler.R')
source('gibbs functions.R')
dat=read.csv('fake data.csv',as.is=T) #frequency of visitation in each location (column) for each time segment (row)
grid.coord=read.csv('fake data grid.csv',as.is=T) #geographical coordinates of locations
#basic setup
ngibbs=10000
nburn=ngibbs/2
n.ac=5
gamma1=0.1
#initial coordinates of activity centers (define this based on data instead of uninformative as below)
ind=sample(nrow(grid.coord),size=n.ac)
ac.coord.init=grid.coord[ind,]
#potential locations for activity centers (AC)
possib.ac=grid.coord #these don't have to be identical (i.e., we can define AC's on a coarser grid)
#run gibbs sampler
options(warn=2)
dat=data.matrix(dat)
res=gibbs.activity.center(dat=dat,grid.coord=grid.coord,n.ac=n.ac,
ac.coord.init=ac.coord.init,gamma1=gamma1,
possib.ac=possib.ac)
plot(res$logl,type='l')
plot(res$phi,type='l')
ntot=n.tsegm*n.ac*n.grid
z.estim=apply(res$z,c(1,3),sum)
z.true=apply(z.true.disagg,c(1,3),sum)
set.seed(1)
#basic setup
n.tsegm=400
n.ac=5
n.grid=100
n=floor(runif(n.tsegm,min=10,max=900))
#spatial coordinates
grid.coord=data.frame(x=runif(n.grid,min=0,max=100),
y=runif(n.grid,min=0,max=100))
ac.ind.true=ind=sample(nrow(grid.coord),size=n.ac)
ac.coord.true=ac.coord=grid.coord[ind,]
rangox=range(c(ac.coord$x,grid.coord$x))
rangoy=range(c(ac.coord$y,grid.coord$y))
plot(ac.coord$x,ac.coord$y,pch=19,xlim=rangox,ylim=rangoy)
points(grid.coord$x,grid.coord$y,col='red')
#generate theta
theta=matrix(NA,n.tsegm,n.ac)
for (i in 1:n.tsegm){
if (i< n.tsegm/2){ #pure thetas
theta[i,]=0
ind=sample(1:n.ac,size=1)
theta[i,ind]=1
}
if (i>= n.tsegm/2){
tmp=runif(n.ac)
theta[i,]=tmp/sum(tmp)
}
}
image(theta)
theta.true=theta
#distance decay parameter
phi.true=phi=0.1
#calculate probabilities associated with each n.ac
probs=matrix(NA,n.ac,n.grid)
for (i in 1:n.ac){
x2=(ac.coord$x[i]-grid.coord$x)^2
y2=(ac.coord$y[i]-grid.coord$y)^2
dist=sqrt(x2+y2)
tmp=exp(-phi*dist)
probs[i,]=tmp/sum(tmp)
}
#cluster membership and data
z=matrix(NA,n.tsegm,n.ac)
z.disagg=array(NA,dim=c(n.tsegm,n.grid,n.ac))
y=matrix(0,n.tsegm,n.grid)
for (i in 1:n.tsegm){
z[i,]=rmultinom(1,size=n[i],prob=theta[i,])
for (j in 1:n.ac){
z.disagg[i,,j]=rmultinom(1,size=z[i,j],prob=probs[j,])
y[i,]=y[i,]+z.disagg[i,,j]
}
}
z.true.disagg=z.disagg
image(y)
ntot=n.tsegm*n.ac*n.grid
z.estim=apply(res$z,c(1,3),sum)
z.true=apply(z.true.disagg,c(1,3),sum)
ordem=numeric()
for (i in 1:ncol(z.true)){
tmp=rep(NA,ncol(z.estim))
for (j in 1:ncol(z.estim)){
tmp[j]=cor(cbind(z.estim[,j],z.true[,i]))[1,2]
}
ind=which(tmp==max(tmp))
print(max(tmp))
ordem=c(ordem,ind)
}
plot(z.estim[,ordem],z.true)
plot(z.estim[,ordem[,2:4]],z.true[,2:4])
plot(z.estim[,ordem[2:4]],z.true[,2:4])
plot(z.estim[,ordem[2:5]],z.true[,2:5])
plot(z.estim[,ordem[1]],z.true[,1])
plot(z.estim[,ordem[2]],z.true[,2])
plot(z.estim[,ordem[3]],z.true[,3])
plot(z.estim[,ordem[4]],z.true[,4])
plot(z.estim[,ordem[5]],z.true[,5])
n.ac=5
ac.coord=matrix(res$coord[ngibbs-1,],n.ac,2)
ac.coord[ordem,]
ac.coord.true
rango=range(c(ac.coord.true),ac.coord[ordem,])
plot(ac.coord.true$x,ac.coord[ordem,1],xlim=rango,ylim=rango)
lines(rango,rango,col='red')
plot(ac.coord.true$y,ac.coord[ordem,2],xlim=rango,ylim=rango)
lines(rango,rango,col='red')
plot(possib.ac$x,possib.ac$y)
points(ac.coord[,1],ac.coord[,2],col='red')
points(ac.coord.true$x,ac.coord.true$y,col='blue',cex=0.8)
plot(possib.ac$x,possib.ac$y)
points(ac.coord[,1],ac.coord[,2],col='red')
plot(possib.ac$x,possib.ac$y)
points(ac.coord.true$x,ac.coord.true$y,col='blue',cex=0.8)
plot(possib.ac$x,possib.ac$y)
points(ac.coord.true$x,ac.coord.true$y,col='red',cex=0.8,pch=19)
points(ac.coord[,1],ac.coord[,2],col='blue')
points(ac.coord[,1],ac.coord[,2],col='blue',cex=1.2)
ordem
rm(list=ls(all=TRUE))
set.seed(3)
#basic setup
n.tsegm=400
n.ac=5
n.grid=100
n=floor(runif(n.tsegm,min=10,max=900))
#spatial coordinates
grid.coord=data.frame(x=runif(n.grid,min=0,max=100),
y=runif(n.grid,min=0,max=100))
ac.ind.true=ind=sample(nrow(grid.coord),size=n.ac)
ac.coord.true=ac.coord=grid.coord[ind,]
rangox=range(c(ac.coord$x,grid.coord$x))
rangoy=range(c(ac.coord$y,grid.coord$y))
plot(ac.coord$x,ac.coord$y,pch=19,xlim=rangox,ylim=rangoy)
points(grid.coord$x,grid.coord$y,col='red')
#generate theta
theta=matrix(NA,n.tsegm,n.ac)
for (i in 1:n.tsegm){
if (i< n.tsegm/2){ #pure thetas
theta[i,]=0
ind=sample(1:n.ac,size=1)
theta[i,ind]=1
}
if (i>= n.tsegm/2){
tmp=runif(n.ac)
theta[i,]=tmp/sum(tmp)
}
}
image(theta)
theta.true=theta
#distance decay parameter
phi.true=phi=0.1
#calculate probabilities associated with each n.ac
probs=matrix(NA,n.ac,n.grid)
for (i in 1:n.ac){
x2=(ac.coord$x[i]-grid.coord$x)^2
y2=(ac.coord$y[i]-grid.coord$y)^2
dist=sqrt(x2+y2)
tmp=exp(-phi*dist)
probs[i,]=tmp/sum(tmp)
}
#cluster membership and data
z=matrix(NA,n.tsegm,n.ac)
z.disagg=array(NA,dim=c(n.tsegm,n.grid,n.ac))
y=matrix(0,n.tsegm,n.grid)
for (i in 1:n.tsegm){
z[i,]=rmultinom(1,size=n[i],prob=theta[i,])
for (j in 1:n.ac){
z.disagg[i,,j]=rmultinom(1,size=z[i,j],prob=probs[j,])
y[i,]=y[i,]+z.disagg[i,,j]
}
}
z.true.disagg=z.disagg
image(y)
setwd('U:\\GIT_models\\AC_mixed')
write.csv(y,'fake data.csv',row.names=F)
write.csv(grid.coord,'fake data grid.csv',row.names=F)
rm(list=ls(all=TRUE))
set.seed(15)
#read important functions
setwd('U:\\GIT_models\\AC_mixed')
library('Rcpp')
sourceCpp('aux1.cpp')
source('gibbs sampler.R')
source('gibbs functions.R')
#get data
dat=read.csv('fake data.csv',as.is=T) #frequency of visitation in each location (column) for each time segment (row)
grid.coord=read.csv('fake data grid.csv',as.is=T) #geographical coordinates of locations
#basic setup
ngibbs=1000
nburn=ngibbs/2
n.ac=5
gamma1=0.1
#initial coordinates of activity centers (define this based on data instead of uninformative as below)
ind=sample(nrow(grid.coord),size=n.ac)
ac.coord.init=grid.coord[ind,]
#potential locations for activity centers (AC)
possib.ac=grid.coord #these don't have to be identical (i.e., we can define AC's on a coarser grid)
#run gibbs sampler
options(warn=2)
dat=data.matrix(dat)
res=gibbs.activity.center(dat=dat,grid.coord=grid.coord,n.ac=n.ac,
ac.coord.init=ac.coord.init,gamma1=gamma1,
possib.ac=possib.ac)
plot(res$logl,type='l')
plot(res$phi,type='l')
set.seed(3)
#basic setup
n.tsegm=400
n.ac=5
n.grid=100
n=floor(runif(n.tsegm,min=10,max=900))
#spatial coordinates
grid.coord=data.frame(x=runif(n.grid,min=0,max=100),
y=runif(n.grid,min=0,max=100))
ac.ind.true=ind=sample(nrow(grid.coord),size=n.ac)
ac.coord.true=ac.coord=grid.coord[ind,]
rangox=range(c(ac.coord$x,grid.coord$x))
rangoy=range(c(ac.coord$y,grid.coord$y))
plot(ac.coord$x,ac.coord$y,pch=19,xlim=rangox,ylim=rangoy)
points(grid.coord$x,grid.coord$y,col='red')
#generate theta
theta=matrix(NA,n.tsegm,n.ac)
for (i in 1:n.tsegm){
if (i< n.tsegm/2){ #pure thetas
theta[i,]=0
ind=sample(1:n.ac,size=1)
theta[i,ind]=1
}
if (i>= n.tsegm/2){
tmp=runif(n.ac)
theta[i,]=tmp/sum(tmp)
}
}
image(theta)
theta.true=theta
#distance decay parameter
phi.true=phi=0.1
#calculate probabilities associated with each n.ac
probs=matrix(NA,n.ac,n.grid)
for (i in 1:n.ac){
x2=(ac.coord$x[i]-grid.coord$x)^2
y2=(ac.coord$y[i]-grid.coord$y)^2
dist=sqrt(x2+y2)
tmp=exp(-phi*dist)
probs[i,]=tmp/sum(tmp)
}
#cluster membership and data
z=matrix(NA,n.tsegm,n.ac)
z.disagg=array(NA,dim=c(n.tsegm,n.grid,n.ac))
y=matrix(0,n.tsegm,n.grid)
for (i in 1:n.tsegm){
z[i,]=rmultinom(1,size=n[i],prob=theta[i,])
for (j in 1:n.ac){
z.disagg[i,,j]=rmultinom(1,size=z[i,j],prob=probs[j,])
y[i,]=y[i,]+z.disagg[i,,j]
}
}
z.true.disagg=z.disagg
image(y)
plot(res$phi,type='l')
abline(h=phi.true,col='red')
ntot=n.tsegm*n.ac*n.grid
z.estim=apply(res$z,c(1,3),sum)
z.true=apply(z.true.disagg,c(1,3),sum)
ordem=numeric()
for (i in 1:ncol(z.true)){
tmp=rep(NA,ncol(z.estim))
for (j in 1:ncol(z.estim)){
tmp[j]=cor(cbind(z.estim[,j],z.true[,i]))[1,2]
}
ind=which(tmp==max(tmp))
print(max(tmp))
ordem=c(ordem,ind)
}
plot(z.estim[,ordem],z.true)
n.ac=5
ac.coord=matrix(res$coord[ngibbs-1,],n.ac,2)
ac.coord[ordem,]
ac.coord.true
rango=range(c(ac.coord.true),ac.coord[ordem,])
plot(ac.coord.true$x,ac.coord[ordem,1],xlim=rango,ylim=rango)
lines(rango,rango,col='red')
plot(ac.coord.true$y,ac.coord[ordem,2],xlim=rango,ylim=rango)
lines(rango,rango,col='red')
#--------------------
#look at spatial distribution
plot(possib.ac$x,possib.ac$y)
points(ac.coord[,1],ac.coord[,2],col='blue',cex=1.2)
points(ac.coord.true$x,ac.coord.true$y,col='red',cex=0.8,pch=19)
plot(possib.ac$x,possib.ac$y)
points(ac.coord[,1],ac.coord[,2],col='blue',cex=2)
points(ac.coord.true$x,ac.coord.true$y,col='red',cex=0.8,pch=19)
rm(list=ls(all=TRUE))
set.seed(15)
#read important functions
setwd('U:\\GIT_models\\AC_mixed')
library('Rcpp')
sourceCpp('aux1.cpp')
source('gibbs sampler.R')
source('gibbs functions.R')
#get data
dat=read.csv('fake data.csv',as.is=T) #frequency of visitation in each location (column) for each time segment (row)
grid.coord=read.csv('fake data grid.csv',as.is=T) #geographical coordinates of locations
#basic setup
ngibbs=1000
nburn=ngibbs/2
n.ac=20
gamma1=0.1
#initial coordinates of activity centers (define this based on data instead of uninformative as below)
ind=sample(nrow(grid.coord),size=n.ac)
ac.coord.init=grid.coord[ind,]
#potential locations for activity centers (AC)
possib.ac=grid.coord #these don't have to be identical (i.e., we can define AC's on a coarser grid)
#run gibbs sampler
options(warn=2)
dat=data.matrix(dat)
res=gibbs.activity.center(dat=dat,grid.coord=grid.coord,n.ac=n.ac,
ac.coord.init=ac.coord.init,gamma1=gamma1,
possib.ac=possib.ac)
plot(res$logl,type='l')
plot(res$phi,type='l')
set.seed(3)
#basic setup
n.tsegm=400
n.ac=5
n.grid=100
n=floor(runif(n.tsegm,min=10,max=900))
#spatial coordinates
grid.coord=data.frame(x=runif(n.grid,min=0,max=100),
y=runif(n.grid,min=0,max=100))
ac.ind.true=ind=sample(nrow(grid.coord),size=n.ac)
ac.coord.true=ac.coord=grid.coord[ind,]
rangox=range(c(ac.coord$x,grid.coord$x))
rangoy=range(c(ac.coord$y,grid.coord$y))
plot(ac.coord$x,ac.coord$y,pch=19,xlim=rangox,ylim=rangoy)
points(grid.coord$x,grid.coord$y,col='red')
#generate theta
theta=matrix(NA,n.tsegm,n.ac)
for (i in 1:n.tsegm){
if (i< n.tsegm/2){ #pure thetas
theta[i,]=0
ind=sample(1:n.ac,size=1)
theta[i,ind]=1
}
if (i>= n.tsegm/2){
tmp=runif(n.ac)
theta[i,]=tmp/sum(tmp)
}
}
image(theta)
theta.true=theta
#distance decay parameter
phi.true=phi=0.1
#calculate probabilities associated with each n.ac
probs=matrix(NA,n.ac,n.grid)
for (i in 1:n.ac){
x2=(ac.coord$x[i]-grid.coord$x)^2
y2=(ac.coord$y[i]-grid.coord$y)^2
dist=sqrt(x2+y2)
tmp=exp(-phi*dist)
probs[i,]=tmp/sum(tmp)
}
#cluster membership and data
z=matrix(NA,n.tsegm,n.ac)
z.disagg=array(NA,dim=c(n.tsegm,n.grid,n.ac))
y=matrix(0,n.tsegm,n.grid)
for (i in 1:n.tsegm){
z[i,]=rmultinom(1,size=n[i],prob=theta[i,])
for (j in 1:n.ac){
z.disagg[i,,j]=rmultinom(1,size=z[i,j],prob=probs[j,])
y[i,]=y[i,]+z.disagg[i,,j]
}
}
z.true.disagg=z.disagg
image(y)
plot(res$phi,type='l')
abline(h=phi.true,col='red')
ntot=n.tsegm*n.ac*n.grid
z.estim=apply(res$z,c(1,3),sum)
z.true=apply(z.true.disagg,c(1,3),sum)
ordem=numeric()
for (i in 1:ncol(z.true)){
tmp=rep(NA,ncol(z.estim))
for (j in 1:ncol(z.estim)){
tmp[j]=cor(cbind(z.estim[,j],z.true[,i]))[1,2]
}
ind=which(tmp==max(tmp))
print(max(tmp))
ordem=c(ordem,ind)
}
plot(z.estim[,ordem],z.true)
ordem=numeric()
options(warn=0)
for (i in 1:ncol(z.true)){
tmp=rep(NA,ncol(z.estim))
for (j in 1:ncol(z.estim)){
tmp[j]=cor(cbind(z.estim[,j],z.true[,i]))[1,2]
}
ind=which(tmp==max(tmp))
print(max(tmp))
ordem=c(ordem,ind)
}
plot(z.estim[,ordem],z.true)
ordem=numeric()
options(warn=0)
for (i in 1:ncol(z.true)){
tmp=rep(NA,ncol(z.estim))
for (j in 1:ncol(z.estim)){
tmp[j]=cor(cbind(z.estim[,j],z.true[,i]))[1,2]
}
ind=which(tmp==max(tmp))
print(max(tmp))
ordem=c(ordem,ind)
}
ordem
ordem=numeric()
options(warn=0)
i=1
tmp=rep(NA,ncol(z.estim))
for (j in 1:ncol(z.estim)){
tmp[j]=cor(cbind(z.estim[,j],z.true[,i]))[1,2]
}
warnings(0)
tmp
ordem=numeric()
options(warn=0)
for (i in 1:ncol(z.true)){
tmp=rep(NA,ncol(z.estim))
for (j in 1:ncol(z.estim)){
tmp[j]=cor(cbind(z.estim[,j],z.true[,i]))[1,2]
}
ind=which(!is.na(tmp) & tmp==max(tmp))
print(max(tmp))
ordem=c(ordem,ind)
}
plot(z.estim[,ordem],z.true)
ordem
